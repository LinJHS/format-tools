name: Build and Release to Aliyun

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build Type'
        required: true
        default: 'private'
        type: choice
        options:
          - private
          - opensource

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: windows-x86_64
            args: ''
          - os: ubuntu-22.04
            platform: linux-x86_64
            args: ''
          - os: macos-latest
            platform: darwin-x86_64
            args: '--target x86_64-apple-darwin'
          - os: macos-latest
            platform: darwin-aarch64
            args: '--target aarch64-apple-darwin'

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.os == 'macos-latest' && 'x86_64-apple-darwin,aarch64-apple-darwin' || '' }}

      - name: Determine Build Type
        id: build-type
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.build_type }}" >> $GITHUB_OUTPUT
          else
            echo "type=private" >> $GITHUB_OUTPUT
          fi

      - name: Clone Private Auth Module
        if: steps.build-type.outputs.type == 'private'
        shell: bash
        env:
          GH_PAT: ${{ secrets.PRIVATE_REPO_PAT }}
        run: |
          cd src
          if [ -n "$GH_PAT" ]; then
             git clone https://$GH_PAT@github.com/LinJHS/format-tools-auth-private.git auth-private
          fi

      - name: Create Environment File
        shell: bash
        run: |
          if [ "${{ steps.build-type.outputs.type }}" == "private" ]; then
            cat > .env.local << EOF
          VITE_ENABLE_AUTH=true
          VITE_EMAS_APP_ID=${{ secrets.EMAS_APP_ID }}
          VITE_EMAS_SPACE_ID=${{ secrets.EMAS_SPACE_ID }}
          VITE_EMAS_CLIENT_SECRET=${{ secrets.EMAS_CLIENT_SECRET }}
          VITE_EMAS_ENDPOINT=${{ secrets.EMAS_ENDPOINT }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD=${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          EOF
          else
            cat > .env.local << EOF
          VITE_ENABLE_AUTH=false
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD=${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          EOF
          fi

      - name: Install dependencies
        run: pnpm install

      - name: Build Tauri App
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          pnpm tauri build ${{ matrix.args }}

      - name: Install Python & OSS2
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - run: pip install oss2

      - name: Upload Artifacts to OSS & Prepare Manifest
        shell: python
        env:
          OSS_KEY_ID: ${{ secrets.ALIYUN_OSS_ACCESS_KEY_ID }}
          OSS_KEY_SECRET: ${{ secrets.ALIYUN_OSS_ACCESS_KEY_SECRET }}
          OSS_BUCKET: ${{ secrets.ALIYUN_OSS_BUCKET }}
          OSS_ENDPOINT: ${{ secrets.ALIYUN_OSS_ENDPOINT }}
          VERSION: ${{ github.ref_name }}
          PLATFORM: ${{ matrix.platform }}
          BASE_URL: https://sw.linjhs.com
        run: |
          import os
          import glob
          import json
          import oss2
          from datetime import datetime

          def clean_version(v):
              return v[1:] if v.startswith('v') else v

          platform = os.environ['PLATFORM']
          tag_version = os.environ['VERSION']
          c_version = clean_version(tag_version)
          
          # Find Artifacts
          # Windows: .exe
          # Linux: .AppImage or .deb (Tauri v2 defaults to AppImage usually for updater?)
          # MacOS: .app.tar.gz or .dmg
          
          extensions = {
              'windows-x86_64': 'src-tauri/target/release/bundle/nsis/*-setup.exe',
              'linux-x86_64': 'src-tauri/target/release/bundle/appimage/*.AppImage',
              'darwin-x86_64': 'src-tauri/target/x86_64-apple-darwin/release/bundle/macos/*.app.tar.gz',
              'darwin-aarch64': 'src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.app.tar.gz' 
          }
          # Note: MacOS updater target is usually .app.tar.gz. 
          # .dmg is for user download, updater usually needs the tar.gz.
          # Verify this for Tauri v2. Tauri v2 updater supports .tar.gz / .zip mostly for mac.
          # If output path is different, glob will fail and we'll see.
          
          pattern = extensions.get(platform)
          if not pattern:
              # Fallback search
              pattern = 'src-tauri/target/release/bundle/*/*'
          
          files = glob.glob(pattern)
          if not files:
              # Try simpler path for mac/linux if release folder differs
              files = glob.glob('src-tauri/target/*/release/bundle/*/*')
          
          # Filter for updater supported extensions
          valid_exts = ('.exe', '.AppImage', '.tar.gz')
          files = [f for f in files if f.endswith(valid_exts) and not f.endswith('.sig')]
          
          if not files:
              print(f"Error: No artifacts found for {platform}")
              exit(1)
              
          exe_path = files[0] # Pick first
          sig_path = f"{exe_path}.sig"
          filename = os.path.basename(exe_path)
          
          print(f"Found: {exe_path}")

          # Upload to OSS
          key_id = os.environ['OSS_KEY_ID']
          key_secret = os.environ['OSS_KEY_SECRET']
          bucket_name = os.environ['OSS_BUCKET']
          endpoint = os.environ['OSS_ENDPOINT']
          
          auth = oss2.Auth(key_id, key_secret)
          bucket = oss2.Bucket(auth, endpoint, bucket_name)
          
          # OSS Structure: /gsj/releases/<platform>/<version>/<filename>
          oss_prefix = f"gsj/releases/{platform}/{c_version}"
          
          print(f"Uploading {filename}...")
          bucket.put_object_from_file(f"{oss_prefix}/{filename}", exe_path)
          
          if os.path.exists(sig_path):
              print(f"Uploading signature...")
              bucket.put_object_from_file(f"{oss_prefix}/{filename}.sig", sig_path)
              with open(sig_path, 'r') as f:
                  signature_content = f.read().strip()
          else:
              print("Warning: No signature file found!")
              signature_content = ""

          # Create Partial Manifest
          manifest_data = {
              "platforms": {
                  platform: {
                      "signature": signature_content,
                      "url": f"{os.environ['BASE_URL']}/gsj/releases/{platform}/{c_version}/{filename}"
                  }
              }
          }
          
          with open(f"{platform}.json", "w") as f:
              json.dump(manifest_data, f)
          
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*-setup.exe
            src-tauri/target/release/bundle/appimage/*.AppImage
            src-tauri/target/x86_64-apple-darwin/release/bundle/macos/*.app.tar.gz
            src-tauri/target/aarch64-apple-darwin/release/bundle/macos/*.app.tar.gz
          draft: true
          prerelease: false

      - name: Upload Partial Manifest
        uses: actions/upload-artifact@v4
        with:
          name: manifest-${{ matrix.platform }}
          path: ${{ matrix.platform }}.json

  publish-manifest:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download Manifests
        uses: actions/download-artifact@v4
        with:
          pattern: manifest-*
          merge-multiple: true
          
      - name: Install Python & OSS2
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - run: pip install oss2

      - name: Merge and Upload Manifest
        shell: python
        env:
          OSS_KEY_ID: ${{ secrets.ALIYUN_OSS_ACCESS_KEY_ID }}
          OSS_KEY_SECRET: ${{ secrets.ALIYUN_OSS_ACCESS_KEY_SECRET }}
          OSS_BUCKET: ${{ secrets.ALIYUN_OSS_BUCKET }}
          OSS_ENDPOINT: ${{ secrets.ALIYUN_OSS_ENDPOINT }}
          VERSION: ${{ github.ref_name }}
          BASE_URL: https://sw.linjhs.com
        run: |
          import os
          import json
          import oss2
          from datetime import datetime

          def clean_version(v):
              return v[1:] if v.startswith('v') else v
              
          c_version = clean_version(os.environ['VERSION'])
          timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
          
          # Try to get release notes from git tag message (or use placeholder)
          # GitHub Actions environment doesn't easily expose tag annotation.
          # We can use a release body if this was a release event, but it's a push tag event.
          # For now, default to simple notes.
          notes = f"Update to version {c_version}"
          
          final_manifest = {
              "version": c_version,
              "name": f"v{c_version}",
              "notes": notes,
              "pub_date": timestamp,
              "platforms": {}
          }
          
          # Merge all partial JSONs
          for file in os.listdir('.'):
              if file.endswith('.json') and file != 'manifest.json':
                  try:
                      with open(file, 'r') as f:
                          data = json.load(f)
                          final_manifest['platforms'].update(data.get('platforms', {}))
                  except Exception as e:
                      print(f"Skipping {file}: {e}")
          
          print("Final Manifest:")
          print(json.dumps(final_manifest, indent=2))
          
          with open("manifest.json", "w") as f:
              json.dump(final_manifest, f)
              
          # Upload to OSS
          key_id = os.environ['OSS_KEY_ID']
          key_secret = os.environ['OSS_KEY_SECRET']
          bucket_name = os.environ['OSS_BUCKET']
          endpoint = os.environ['OSS_ENDPOINT']
          
          auth = oss2.Auth(key_id, key_secret)
          bucket = oss2.Bucket(auth, endpoint, bucket_name)
          
          # Upload global manifest to gsj/manifest.json
          # This aligns with the new endpoint: https://sw.linjhs.com/gsj/manifest.json
          
          manifest_key = "gsj/manifest.json"
          print(f"Uploading manifest to {manifest_key}...")
          bucket.put_object_from_file(manifest_key, "manifest.json")
